## 阅读lodash中一段长正则理解笔记

在lodash源码`/.internal/stringToPath.js`中：

这里英文是原注释，中文是简单的翻译下，后面会详细解释：
```js
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  // 匹配任意 非.和非[]的任意值(1个以上)
  '[^.[\\]]+' + '|' +
  // Or match property names within brackets.
  // 匹配 [
  '\\[(?:' +
    // Match a non-string expression.
    // 匹配(非" 或者 ')和后面任意数量值，即非字符串
    '([^"\'].*)' + '|' +
    // Or match strings (supports escaping characters).
    // 匹配字符串(支持转义字符)
    '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
  ')\\]'+ '|' +
  // Or match "" as the space between consecutive dots or empty brackets.
  // 匹配连续的点或者中括号，然后匹配值为""
  '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))'
, 'g')
```

## 理解
* 第一行

`'[^.[\\]]+' + '|' +`

一个兜底的匹配，意思是匹配除了`.`和`[]`的任意值，后面的如果能匹配则会覆盖这个(因为后面的匹配字符更多)；

例如：
```js
'abc'.match(/([^a]+|a(.)c)/)

// 这里两个都能匹配，前面匹配值为'bc'，后面的匹配值为'abc'，因此后面的优先匹配
```

这里要注意的就是在字符串中转义需要写两次`\\`，而且这里`.`是不需要转义，后面那个`]`需要转义因为构成了歧义。

* 第二行

`'\\[(?:' +`

这里有一个`?:`，意思是在这个括号内，匹配值但不需要储存匹配结果

* 第三行

`'([^"\'].*)' + '|' +`

没有什么特别的...

* 第四行

`'(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +`


先看`(["\'])`

也就是匹配双|单引号；

接着分两种匹配：

##### 4-1 

`((?:(?!\\2)[^\\\\]`

这里首先是`?!`，正向否定预查，意思是只有(同一个括号内)后面的不满足，才能去匹配前面的值；

后面是`\\2`，转义后就是`\2`，意思就是反向引用第二个括号储存的结果，就是`(["\'])`；

因此`(?!\\2)`这里就是只要不是双|单引号，因为第四行最后有`*`，因此这里会抓取任意多个不是引号的字符，然后储存到括号匹配内（后面使用时的[第四个参数](#参数含义))）；

能抓取到这些值后，就去匹配前面的值，前面的值就是`(["\'])`，还是双|单引号，如果不能抓取这些值(例如连续多个引号)，则无法匹配；

`\\\\`转义后就是`\\`，意思就是匹配一个斜杠` \ `，这里就是不匹配` \ `；

所以这句的意思就是：匹配单个引号后面的非引号值，并且它后面不能是斜杠` \ `

##### 4-2 

`|\\\\.`

转义后就是`\\.`，意思就是匹配一个斜杠` \ `后面可以是任意值（*其实就是匹配转义字符*，例如\a）


最后`*?)\\2`

这里用了非贪婪模式，量词后面加`?`，再搭配后面的`\\2`（前面说了，也就是引号）。

整体的意思就是：***前面2种匹配([4-1](#4-1),[4-2](#4-2))，任何一种匹配后，匹配任意位数，直到出现第一个引号***。

* 第五行

`')\\]'+ '|' +`

这里匹配了`]`，就是补充了第二行匹配的`[`；因此我们知道从第二行到第五行的匹配，都是对在中括号`[]`内匹配类型的处理。

* 第六行

`'(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))'`

`?=`是正向肯定预查，即符后面匹配的，去匹配前面的值，但它前面没有值，就会匹配为空`""`；

因此这行含义就是：出现了`..`或者`[][]`或者单独的`.`和单独的`[]`会转换成`""`

* 第七行

`, 'g')`

全局匹配

## 使用

```js
string.replace(rePropName, (match, expression, quote, subString) => {
let key = match
if (quote) {
  // 将 \\ 转换成 \
  key = subString.replace(reEscapeChar, '$1')
}
else if (expression) {
  // 去两端空格
  key = expression.trim()
}
result.push(key)
})
```

这里`replace`第二个参数是函数，因此函数的参数按以下顺序排列：
1. 匹配值
2. 匹配过程中括号内储存(匹配)的值，有多个则占用多个参数位置

    ...
    
3. 匹配值对应的索引
4. 输入的字符串

##### 参数含义

`match`是整个表达式匹配的值
 
`expression`匹配*中括号内*非字符串 
 
`quote`匹配*中括号内*第一个引号(后面不能也是引号，就是不能重复) 
 
`subString`是*中括号内*具体字符串的值(无引号)

因此：

`if (quote)`说明中括号内是字符串，有可能有转义，要进行处理。

`if (expression)`说明中括号内是非字符串，是属性值，需要去空格处理。

## 总结

通过这个正则，学到了：

1. 正则匹配以匹配字符多的优先。
2. `\1`, `\2`, `?!`, `?=`, `?:`, 在字符串中`\\\\`的使用。
3. 使用 `?!`，遇到重复值，取消后面部分匹配(从而减少匹配优先权)。
```js
// 这里a设定不能为重复值

"abc".match(/a((?!a).)*/)
// 匹配值：abc
"aabc".match(/a((?!a).)*/)
// 匹配值：a
```
4. 使用`?=`置空匹配值
```js
// 只要连续出现abcd 则匹配为空

'abced'.match(/(?=.*abcd.*)|.*/)
// 匹配值：abced
'eabcdd'.match(/(?=.*abcd.*)|.*/)
// 匹配值：''
```
5. replace第二参数函数的使用，括号的匹配有值会增加函数参数的数量。
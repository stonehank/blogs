实体首部字段

* Content-Encoding：实体编码方式(gzip, compress, deflate, identity)
* Content-Location：报文主体返回资源对应的 URI(不一定是请求URI)。
* Content-Range：匹配部分。
* Content-Type：实体内对象的媒体类型。
* Last-Modified：指明资源最终修改的时间。

----

Cookie相关字段

|首部字段名 |说明 |首部类型|
|----|---|---|
|Set-Cookie |开始状态管理所使用的Cookie信息| 响应首部字段|
|Cookie |服务器接收到的Cookie信息 |请求首部字段|

* Set-Cookie

    `Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;`

* Set-Cookie 字段的属性

|属性 |说明|
|----|----|
|NAME=VALUE |赋予 Cookie 的名称和其值（必需项）|
|expires=DATE |Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|
|path=PATH|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）
|domain=域名|作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）|
|Secure |仅在 HTTPS 安全通信时才会发送 Cookie
|HttpOnly |加以限制，使 Cookie 不能被 JavaScript 脚本访问|

* Cookie：status=enable

* DNT：属于 HTTP 请求首部，为`1`拒绝个人信息被征集，`0`允许。

----

HTTP 的不足

* 通信使用明文（不加密），内容可能会被窃听
    * TCP/IP 是可能被窃听的网络（即便不使用明文）
    * 通信的加密 （HTTPS)
    * 内容的加密 （双方都具有加密解密能力）
* 不验证通信方的身份，因此有可能遭遇伪装
    * 任何人都可发起请求
    * HTTPS可以确认对方的证书
* 无法证明报文的完整性，所以有可能已遭篡改
    * 接收到的内容可能有误（中间人攻击）

----

SSL采用`公钥`和`私钥`

HTTPS 采用混合加密机制

机制前提：公开密钥加密与共享密钥加密相比，其处理速度要慢

1. 在交换密钥（共享密钥）环节使用公开密钥加密方式
2. 之后的建立通信交换报文阶段则使用共享密钥加密方式

----

在使用公钥加密之前，如何确保接收到的公钥是正确的

1. 公钥放置在公钥证书（数字证书）内部。
2. 浏览器内置了常用第三方认证的公开密钥（用于对数字证书进行校验）。

-----

可证明组织真实性的 EV SSL 证书

-----

客户端证书

需要费用，用于特殊用途的业务，例如网银。

-----

HTTPS 的安全通信机制

1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、
加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。

    总结：(协商加密组件，验证SSL版本)

2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，
在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。

    总结：回应SSL版本，确认加密组件

3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。

    总结：发生公钥证书（包含公钥）

4. 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。

5. SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。
报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。
该报文已用步骤 3 中的公开密钥进行加密。

    总结：对共享密钥使用公钥加密并且发送

6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，
在此报文之后的通信会采用 Pre-master secret 密钥加密。

    总结：提示准备进行共享密钥加密（速度快）

7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。
这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。

    总结：最后一次总验证

8. 服务器同样发送 Change Cipher Spec 报文。

9. 服务器同样发送 Finished 报文。

    总结：确认使用共享密钥加密，三次握手结束

10. 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。
当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。

11. 应用层协议通信，即发送 HTTP 响应。

    总结：后续直接HTTP协议通信（使用共享密钥）

12. 最后由客户端断开连接。断开连接时，发送 close_notify 报文。




题目给定一个网格，遇见`1`表示能摘取1个樱桃，遇到`0`表示空地，遇到`-1`表示荆棘不能走。

要求从左上走到右下，再从右下走回左上，樱桃摘掉就会从`1`变`0`，问能摘取的最大樱桃数。

这道题初一看有点像`路径最大和`问题，但细想不能这么做，因为走完第一次，摘取的樱桃会消失，
因此子问题互相有影响。

 思路：
 1. 走2次，由于走完第一次，摘取的樱桃会消失，因此不能使用单程DP*2，因为子问题互相有影响。
 2. 可以看成是2个人一起从左上走到右下，或者从右下走到左上。
 3. 由于2个人是同步行走，因此任何一方超出规则，都视为无效路径。
 4. 当他们走到同一格，只能摘取1个樱桃。
 5. 使用mem记录他们走过的格子不必重复计算，复杂度从指数降到3次方


```js
var cherryPickup = function(grid) {
  let n=grid.length
  let mem=[]
  // 创建mem，记录x1,y1和x2,y2的行走记录
  for(let i=0;i<n;i++){
    mem[i]=[]
    for(let j=0;j<n;j++){
      mem[i][j]=[]
      for(let k=0;k<n;k++){
        mem[i][j][k]=-Infinity
      }
    }
  }
  return Math.max(0,dp(n-1,n-1,n-1))
  // 返回从x1,y1 和 从x2,y2一起走到 0,0能最多摘到樱桃数
  function dp(x1,y1,x2){
    let y2=x1+y1-x2
    // 任意一个超出边界 返回
    if(x1<0||x2<0||y1<0||y2<0)return -1
    // 任意一个进入荆棘，返回
    if(grid[x1][y1]<0 || grid[x2][y2]<0)return -1
    // 到达终点，返回
    if(x1===0 && y1===0)return grid[x1][y1]
    // 存在记录，直接返回记录
    if(mem[x1][y1][x2]!==-Infinity)return mem[x1][y1][x2]
    // 子问题，分别计算x1,y1 和 x2,y2的所有能走的情况(4种)
    let res=Math.max(dp(x1-1,y1,x2-1),dp(x1-1,y1,x2),dp(x1,y1-1,x2-1),dp(x1,y1-1,x2))
    // 子问题无解，返回并且记录-1
    if(res<0)return mem[x1][y1][x2]=-1
    // 获取x1,y1摘得樱桃数
    res+=grid[x1][y1]
    // 如果x1,y1和x2,y2不在同一个位置，加上x2,y2摘的樱桃数
    if(x1!==x2 && y1!==y2)res+=grid[x2][y2]
    // 记录
    mem[x1][y1][x2]=res
    return res
  }
};
```
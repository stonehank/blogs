给定一个数组，只由`0`和`1`组成。要求三等分，使得他们的对应的十进制的值相等。

这道题我最初思路是`window slide`，通过设定2个指针，`left`和`right`，每次移动判断当前应该`left`增减还是`right`增加。

结果是`TLE`，给定的数组范围是`[3,30000]`，这道题是存在`O(N)`的解，充分利用只存在`0`和`1`这一特性。

思路：所有的`0`作为每一个字符串的开头，相当于没有
1. 因为可能存在`[0,0,1,0]`与`[1,0]`相等的情况，因此对于`0`，首先不去处理，只记录`1`的数量和1的位置。
2. 对于所有的`1`，将数组分割成3段具有相同`1`的数量的，如果无法分割，则无解。
3. 对于`[1,0,1,0,1,0]`这种情况，我们分割了`1`，接着处理每一段`1`**后面**的`0`，前面的不需要处理。
4. 对于第一段和第二段，它们后面的`0`，可以超过第三段，但不能少于第三段，这是因为如果第一段后的`0`更多，
可以让它接在第二段开头，如果第二段后面`0`更多，可以让它接在第三段开头，但是如果第三段后面的`0`更多，再没有能给它接的。

代码：
```js
var threeEqualParts = function(A) {
  let IMP = [-1, -1];
  let N = A.length;

  let S = 0;
  for (let x of A) S += x;
  // 1的数量不是3的倍数，返回impossible
  if (S % 3 != 0) return IMP;
  let T = S / 3;
  // 不存在1，返回[头,尾]
  if (T == 0) return [0, N - 1];

  // 通过上面确定了，每一个字符串中的1的数量必须为T
  // 当发现1开头，给第一个字符串，当到T时，第一个字符串结尾
  // T+1时，给第二个字符串....
  let i1 = -1, j1 = -1, i2 = -1, j2 = -1, i3 = -1, j3 = -1;
  let su = 0;
  // 分割成三段 以1开头并且以1结尾，具有相同长度的子数组
  for (let i = 0; i < N; ++i) {
    if (A[i] == 1) {
      su += 1;
      if (su == 1) i1 = i;
      if (su == T) j1 = i;
      if (su == T+1) i2 = i;
      if (su == 2*T) j2 = i;
      if (su == 2*T + 1) i3 = i;
      if (su == 3*T) j3 = i;
    }
  }


  let part1 = A.slice(i1,j1+1)
  let part2 = A.slice(i2,j2+1)
  let part3 = A.slice(i3,j3+1)

  // 检测这3个数组如果不相等，返回impossible
  for(let i=0;i<part1.length;i++){
    if(part1[i]!==part2[i] || part1[i]!==part3[i])return IMP
  }
  
  // 第一段后面的0的数量
  let x = i2 - j1 - 1;
  // 第二段后面的0的数量
  let y = i3 - j2 - 1;
  // 第三段后面的0的数量
  let z = A.length - j3 - 1;

  if (x < z || y < z) return IMP;
  return [j1+z, j2+z+1];
};
```

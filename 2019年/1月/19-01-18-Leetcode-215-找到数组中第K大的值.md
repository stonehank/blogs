在之前的文章`9-11-二分查找的range方法`，使用了`二分查找`解决这道题，但实际上还是`O(nlgn)`，相比起排序，并不是一个特别
有效的优化，这次使用`快速选择`，`快速排序`算法的一个变体。

思路：
1. 快速排序我们都很清楚，每一次选中一个`pivot`，将小于它的放左边，大于它的放右边，执行`lgN`次。
2. 快速选择同理，唯一的区别是当每次左右排序后，检查我们要找的值是在左边还是在右边，然后继续执行`左`或者`右`，另一边丢弃。

代码：

```js
function quickSelect(arr,k){
  let idx=_qs(arr,0,arr.length-1,k)
  return arr[idx]
 
  function _qs(arr,lo,hi,target){
    let i=lo,j=hi,pivot=arr[hi]
    while(i<j){
      if(arr[i]<pivot)i++
      else swap(arr,i,--j)
    }
    swap(arr,i,hi)
    // 数一下当前比 i 位置大的数量
    let curCount=hi-i+1
    // 当前数量和目标一致，返回
    if(curCount===target)return i
    // 当前数量更多，说明这个值偏小，需要在右边找
    else if(curCount>target)return _qs(arr,i+1,hi,target)
    // 当前数量更少，说明这个值偏大，需要在左边找，同时要减去已经找到的数量
    else return _qs(arr,lo,i-1,target-curCount)
  }
  function swap(arr,i,j){
    let t=arr[i]
    arr[i]=arr[j]
    arr[j]=t
  }
}
```
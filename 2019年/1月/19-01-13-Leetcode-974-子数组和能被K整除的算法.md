首先是子数组和为某个值的计算。

当计算子数组和为某一个值的数量，我们需要使用一个`hash`保存当前的和。

这样当下一次计算`hash[sum-target]`的时候，可以快速找出以前保存过的子数组的数量，

例如`[1,2,3,4,5]`

遍历一遍后`hash`为`{1:1, 3:1, 6:1, 10:1, 15:1}`

当我们计算到`index为2（数值为3）`的时候，这时`sum`为6，并且由于存在`hash[6-5]`，说明`123`这个子数组中是存在和为`5`的。

代码：

```js
function calcSumCount(arr,target){
  let hash={},sum=0,res=0
  hash[0]=1
  for(let i=0;i<arr.length;i++){
    sum+=arr[i]
    res+=hash[sum-target] || 0
    if(!hash[sum])hash[sum]=1
    else hash[sum]++
  }
  return res
}
```

-----

接着是来自`leetcode：974. Subarray Sums Divisible by K`，这道题是关于子数组和的一个变形。

题目要求计算出子数组和能被K整除的数量。

例如：`A=[4,5,0,-2,-3,1], K=5`，结果是`7`，存在以下子数组

```
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

思路：

和上面一样，题目都是要求计算子数组的和，但这次要额外计算是否能被整除，而不是等于某个数

被整除也就是用`%`处理，我们需要保存每一次的`%`，因为如果当前算出的模，在`hash`中已经存在，那么说明已经找到了能被K整除的子数组。

但是，还需要额外考虑一个因素，那就是负数，如果不对负数的模进行处理，当同时出现正负数，会错过一些正确的值。

例如考虑`[4,-2,-3]` `K`为5,，如果我们按照上面的办法，那么当计算到`index为2(值为-3)`的时候，`hash`为`{4:1, 2:1}`，
这时的`sum`是`4+ -2`，现在再加`-3`，sum为`-1`，模为`-1 % 5 =-1`，我们发现，hash中并没有模为 `-1`的值，但其实`-1`是一个
需要收集的答案，因为`-2 + -3`能被`5`整除。

因此当`sum`为负数时，我们需要转换为正数，再去从`hash`中获取。

代码：

```js
var subarraysDivByK = function(A, K) {
  let hash={},sum=0,res=0
  hash[0]=1
  for(let i=0;i<A.length;i++){
    sum+=A[i]
    if(sum<0) sum+=K*Math.ceil(-sum/K)
    let m=sum % K
    if(hash[m]==null)hash[m]=0
    res+=hash[m]
    hash[m]++
  }
  return res
};
```




数组 A 是 [0, 1, ..., N - 1] 的一种排列，N 是数组 A 的长度。全局倒置指的是 i,j 满足 0 <= i < j < N 并且 A[i] > A[j] ，局部倒置指的是 i 满足 0 <= i < N 并且 A[i] > A[i+1] 。

当数组 A 中全局倒置的数量等于局部倒置的数量时，返回 true 。

```
示例 1:
输入: A = [1,0,2]
输出: true
解释: 有 1 个全局倒置，和 1 个局部倒置。

示例 2:
输入: A = [1,2,0]
输出: false
解释: 有 2 个全局倒置，和 1 个局部倒置。
```
注意:
* A 是 `[0, 1, ..., A.length - 1]` 的一种排列
* A 的长度在`[1, 5000]`之间
* 这个问题的时间限制已经减少了。

-----

思路：
1. 最初看到问题的想法是将全局倒置数量和局部倒置数量都计算出来，最后对比，但是`TLE`了，这么做时间复杂度是`O(N^2)`。

2. 其实仔细一思考，一旦发现存在全局倒置，就可以立刻返回`false`了，因此有局部倒置必然有全局倒置，而有全局倒置不一定有局部倒置。

3. 遍历的时候将遍历过的最大值保存，一旦发现当前值小于这个最大值，说明存在额外的全局倒置，最终时间复杂度是`O(N)`

-----

代码：
```js
/**
 * @param {number[]} A
 * @return {boolean}
 */
var isIdealPermutation = function(A) {
  let max=-Infinity
  for(let i=1;i<A.length;i++){
    if(A[i]<max)return false
    max=Math.max(max,A[i-1])
  }
  return true
};
```
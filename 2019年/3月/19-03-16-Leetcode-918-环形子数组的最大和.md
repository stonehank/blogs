给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length 时 C[i] = A[i]，而当 i >= 0 时 C[i+A.length] = C[i]）

此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）

``` 
示例 1：

输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
示例 2：

输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
示例 3：

输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4
示例 4：

输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
示例 5：

输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1
```

提示：

-30000 <= A[i] <= 30000
1 <= A.length <= 30000

-----
思路：

这道题有几种思路。

思路一：(和`862.和至少为K的子数组`很相似)

1. 因为是环形数组，我们创建一个数组`P`，它的长度为`2*N`，并且`P[i]`表示从`0-i`的和。
2. 定义一个`stack`，里面维护了能作为开头的子数组的索引。
3. 遍历P，我们要执行以下2点条件：
    1. 当长度超过`N`时，删除`stack`头部的索引。
    2. 当`P[j]<=P[stack[stack.length-1]]`时，说明当前`j`所在的位置是0或者负数，不能作为子数组的开头。
    
代码：
```js
/**
 * @param {number[]} A
 * @return {number}
 */
var maxSubarraySumCircular = function(A) {
  let N = A.length;
  let P = Array(2*N+1).fill(0)
  for (let i = 0; i < 2*N; ++i){
    P[i+1] = P[i] + A[i % N]
  }
  let ans = A[0];
  let stack = [0]
  for (let j = 1; j <= 2*N; ++j) {
    if (stack[0] < j-N)stack.shift()
    ans = Math.max(ans, P[j] - P[stack[0]]);
    while (stack.length>0 && P[j] <= P[stack[stack.length-1]]){
      stack.pop()
    }
    stack.push(j)
  }
  return ans;
};
```

思路二：

如果不是环形数组，我们可以使用`Kadane`算法计算出子数组的最大和。

那么环形数组比非环形数组多了一种情况，那就是`部分尾巴+部分头部`为最大和的子数组，这种情况我们只需要考虑，和最小的子数组，
也就是中间那一部分。

因此我们只需比较`最大和的子数组`和`数组总和-最小和的子数组`。

代码：
```js
/**
 * @param {number[]} A
 * @return {number}
 */
var maxSubarraySumCircular = function(A) {
  let total = 0, 
      maxSum = -Infinity, curMax = 0, 
      minSum = Infinity, curMin = 0,
      maxSingle=-Infinity
  for (let a of A) {
    total += a;
    maxSingle=Math.max(maxSingle,a)
    
    if(curMax+a>0){
      curMax+=a
      maxSum=Math.max(curMax,maxSum)
    }else curMax=0

    if(curMin+a<0){
      curMin+=a
      minSum=Math.min(curMin,minSum)
    }else curMin=0   
  }
  return maxSum > 0 ? Math.max(maxSum, total - minSum) : maxSingle;
};
```
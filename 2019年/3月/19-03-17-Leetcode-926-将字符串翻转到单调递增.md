如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。

返回使 S 单调递增的最小翻转次数。

```
示例 1：

输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：

输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：

输入："00011000"
输出：2
解释：我们翻转得到 00000000。
```

提示：

1 <= S.length <= 20000
S 中只包含字符 '0' 和 '1'

-----
思路：

这道题要求3种格式，分别是`00`,`01`,`11`

因此，数字`0`前面必须是`0`，数字`1`前面可以是`0`或者`1`。

我们定义2个数组`beZero`和`beOne`，分别用来保存如果当前值要反转成`0`或者`1`需要的次数。

通过上面分析，可以得到以下公式：

```
if S[i]=="0":
beZero[i]=beZero[i-1]
beOne[i]=Math.min(beZero[i-1],beOne[i-1]) + 1

if S[i]=="1":
beZero[i]=beZero[i-1] + 1
beOne[i]=Math.min(beZero[i-1],beOne[i-1])
```

-----

代码：
```js
/**
 * @param {string} S
 * @return {number}
 */
var minFlipsMonoIncr = function(S) {
  let n=S.length
  let beZero=Array(n+1).fill(0),
      beOne=Array(n+1).fill(0)
  for(let i=0;i<n;i++){
    if(S[i]==='0'){
      beZero[i+1]=beZero[i]
      beOne[i+1]=Math.min(beZero[i],beOne[i])+1
    }else{
      beZero[i+1]=beZero[i]+1
      beOne[i+1]=Math.min(beZero[i],beOne[i])
    }
  }
  return Math.min(beZero[n],beOne[n])
};
```
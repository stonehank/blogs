给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。

每个子数组的长度为k，我们要使这3*k个项的和最大化。

返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。
```
示例:

输入: [1,2,1,2,6,7,5,1], 2
输出: [0, 3, 5]
解释: 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。
我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
```

-----

思路：由于题目有`k`的限制，我们首先要将所有`k`项的子数组和计算出来。

例如：`nums=[1,4,2,3,5,7,8],k=2`

计算的结果为`gapSums=[5,6,5,5,12,15]`

而且题目规定了由`3组子数组`组成的最大和，因此我们需要在上面计算结果中找出相差`k`项并且和为最大的3组。

`dp[i][j]`表示了到达`gapSums`中索引`j`的位置时，由`i`组(1<=i<=3)组成的最大和。

递推公式为：

`dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j-k]+gapSums[j])`

最后，再通过反查找出每一组中最大值的最前面的位置，从而获取最大和的索引。

代码：
```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSumOfThreeSubarrays = function(nums, k) {
  let sums=[0]
  for(let i=0;i<nums.length;i++){
    sums[i+1]=sums[i]+nums[i]
  }
  
  let gapSum=[]
  for(let i=0;i<sums.length-k;i++){
    gapSum.push(sums[i+k]-sums[i])
  }
  
  let N=gapSum.length
  let dp=Array(4).fill().map(()=>Array(N).fill(0))
  for(let i=1;i<dp.length;i++){
    for(let j=k*(i-1);j<N;j++){
      dp[i][j]=Math.max((dp[i][j-1] || 0),(dp[i-1][j-k] || 0)+gapSum[j])
    }    
  }
  
  let ans=[],rest=dp[3][N-1]
  for(let i=3;i>=1;i--){
    let idx=bs(dp[i],rest)
    ans.unshift(idx)
    rest-=gapSum[idx]
  }
  return ans
  
  
  function bs(arr,n){
    let l=0,h=arr.length-1
    while(l<h){
      let mid=Math.floor((l+h)/2)
      if(arr[mid]<n)l=mid+1
      else h=mid
    }
    return l
  }
};
```
给定一个整数数组 A，坡是元组 (i, j)，其中  i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

 
```
示例 1：

输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
示例 2：

输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
```

提示：

1. 2 <= A.length <= 50000
2. 0 <= A[i] <= 50000

-----
思路：

这道题我们需要对原数组构造出一个降序数组和升序数组，例如：`[6,0,8,2,1,5]`

`[index(val)]`

降序数组为：`[0(6),1(0)]`，升序数组为`[5(5),2(8)]`

为什么这么做有效呢

例如在最后一个元素`5`前面并且`<=5`的元素，他们能获取的长度一定不会超过`5`能获取的长度。

同样，在元素`0`后面并且`>=0`的元素，他们对应的长度也一定不会超过`0`能获取的长度。

因此，我们只需要对升序数组和降序数组进行处理即可。

遍历升序数组，一旦发现匹配的降序数组，直接`pop`，因为降序数组这个匹配的值的长度一定是当前值的最大长度。


-----

代码：
```js
/**
 * @param {number[]} A
 * @return {number}
 */
var maxWidthRamp = function(A) {
  let n=A.length
  let dec=[],inc=[]
  for(let i=0;i<n;i++){
    if(dec.length===0 || A[dec[dec.length-1]]>A[i]){
      dec.push(i)
    }
  }
  for(let i=n-1;i>=0;i--){
    if(inc.length===0 || A[inc[inc.length-1]]<A[i]){
      inc.push(i)
    }
  }
  let maxLen=0
  for(let i=0;i<n;i++){
    while(dec.length>0 && A[dec[dec.length-1]]<=A[inc[i]]){
      maxLen=Math.max(maxLen,inc[i]-dec.pop())
    }
  }
  return maxLen
};
```

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

```
示例 1:
输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。

示例 2:
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```

思路：
考虑一个例子，当我们知道`n=6`和`k=(0~3)`时的值为`dp[6][0]`,`dp[6][1]`,`dp[6][2]`,`dp[6][3]`

那么如果`n=7`,`k=3`，应该如何转换？

如果`7`放在第一位，则为`7(x*6)`，那么会增加6个逆序。

如果`7`放在第二位，则为`(x)7(x*5)`，那么会增加5个逆序。

...

因此，在这里，我们能够有效转换有(不需要管具体插入哪个位置，反正插入的那个位置能达到增加逆序的要求数量)

`dp[6][0]+插入7增加3个逆序`

`dp[6][1]+插入7增加2个逆序`

`dp[6][2]+插入7增加1个逆序`

`dp[6][3]+插入7增加0个逆序`

我们的转换为：

`dp[7][3] = dp[6][0]+dp[6][1]+dp[6][2]+dp[6][3]`

这种写法的时间复杂度是`O(n^2*k)`，最坏情况`n`,`k`都是1000，会TLE。

因此，需要优化一下，我们以`dp[i][j]`表示 `n==i`和`k==0~j`时的总和。

状态转移方程为：

`dp[i][j]=dp[i][j-1] + dp[i-1][j] - (j>=i ? dp[i-1][j-i] : 0)`

其中` (j>=i ? dp[i-1][j-i] : 0)`表示当超出极限时，需要减去之前的和

例如`n=7`的极限就是增加逆序数为6个，可以是`0~6`或者`1~7`等等。

代码：

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function(n, k) {
  let dp=Array(n+1).fill().map(()=>Array(k+1).fill(0))
  for(let i=1;i<n+1;i++){
    dp[i][0]=1
  }
  let MOD=1e9+7
  for(let i=1;i<n+1;i++){
    for(let j=1;j<k+1;j++){
      let val=(dp[i-1][j]-(j>=i ? dp[i-1][j-i] : 0) + MOD) % MOD
      dp[i][j]=(dp[i][j-1]+val) % MOD
      
    }
  }
  return (dp[n][k]-(dp[n][k-1] || 0)+MOD) % MOD
};
```
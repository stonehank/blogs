给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

这道题用`DP`解就是`O(n^2)`时间复杂度。

思路：
创建一个`dp数组`，用来储存每个`index`及它之前的最长子序列，`dp[j]`会去检查前面的每一个`dp[i]`，如果`nums[i]<nums[j]`，
那么`dp[j]=Math.max(dp[j],dp[i]+1)`。

代码：
```py
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        maxLen=0
        n=len(nums)
        dp=[1]*n
        for i in range(n):
          cur=nums[i]
          for j in range(0,i):
            if nums[j]<cur:
              dp[i]=max(dp[i],dp[j]+1)
          maxLen=max(dp[i],maxLen)
        return maxLen
```

另外一个`O(nlgn)`的方法不太容易想到，需要搭建一个`单调递增数组`。

思路：
维护一个数组`stack`，当`stack[-1]`比当前`nums[i]`小的时候，直接`append`，如果更大，需要二分搜索到`nums[i]`应该存在的位置，
并且替换，最终`stack`的长度就是最长结果。

例如`[1,3,6,7,9,4,10,5,6]`

当`nums[i]`为`4`时，`stack`为`[1,3,6,7,9]`
当`nums[i]`为`10`时，`stack`为`[1,3,4,7,9]`

代码：
```py
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        stack=[]
        for num in nums:
          if not stack or stack[-1]<num:
            stack.append(num)
          elif stack[-1]>num:
            lo,hi=0,len(stack)-1
            while lo<hi:
              mid=(lo+hi)//2
              if stack[mid]<num:
                lo=mid+1
              else:
                hi=mid
            stack[lo]=num
        return len(stack)
```
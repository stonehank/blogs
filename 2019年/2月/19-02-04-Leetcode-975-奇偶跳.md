题目给定一个数组`A`，并且定义从`i`点的奇数跳为`i`点之后`>=A[i]`的最小值，从`i`点的偶数跳为`i`点之后的`<=A[i]`的最大值。

求能跳到终点的`i`的数量。

-----

思路：

这道题暴力解是`O(N^2)`，从每一个点，模拟是否能跳到终点。

但如果逆序遍历，则会发现当前点`i`需要找的值就在已经遍历的集合内部，因此可以使用`TreeMap`，通过查找当前点的`ceil`和`floor`，
时间复杂度是`O(NlgN)`。

-----
代码：这里模拟了`TreeMap`的功能。
```js
var oddEvenJumps = function(A) {
  let list=[],res=1
  let odd=Array(A.length).fill(false),even=Array(A.length).fill(false)
  odd[A.length-1]=true
  even[A.length-1]=true
  insert(A[A.length-1],A.length-1)
  for(let i=A.length-2;i>=0;i--){
    // 逆序很重要，能保证每次只找它之后的数据
    // 先找奇数跳的位置(>=A[i]的最小值)和偶数跳的位置(<=A[i]的最大值)
    let oddIdx=ceil(A[i]),
        evenIdx=floor(A[i])
    // 如果当前是奇数跳，那么判断下一个位置的偶数跳是否为true，为true，则当前奇数跳为true
    // 如果当前是偶数跳，那么判断下一个位置的奇数跳是否为true，为true，则当前偶数跳为true
    if(evenIdx!==-1 && odd[evenIdx])even[i]=true
    if(oddIdx!==-1 && even[oddIdx])odd[i]=true
    // 如果当前奇数跳为true，res++
    if(odd[i])res++
    insert(A[i],i)
  }
  return res
  function insert(n,id){
    if(list.length===0 || list[list.length-1][0]<=n){
      list.push([n,id])
    }else{
      let idx=bsEnd(list,n)
      list.splice(idx,0,[n,id])
    }
  }
  // 找到大于n的最小值在原数组的索引
  function ceil(n){
    if(n>list[list.length-1][0])return -1
    else if(n<list[0][0])return list[0][1]
    else{
      let idx=bsEnd(list,n)
      return list[idx][1]
    }
  }
  // 找到小于n的最大值在原数组的索引
  function floor(n){
    if(n<list[0][0])return -1
    else if(n>list[list.length-1][0])return list[list.length-1][1]
    else{
      let idx=bsEnd(list,n)
      if(list[idx][0]!==n){
        idx=bsEnd(list,list[--idx][0])
      }
      return list[idx][1]
    }
  }
  function bsEnd(arr,n){
    let lo=0,hi=arr.length-1
    while(lo<hi){
      let mid=Math.floor((lo+hi)/2)
      if(arr[mid][0]<n)lo=mid+1
      else hi=mid
    }
    return hi
  }
};
```

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。

```
示例 1:
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
```

-----
思路：
这道题首先要计算出前32位的斐波那契数，原因如下：

当二进制k为`1-4位`的解如下：
```
             / 1000
         100      
       /     \ 1001      
  / 10          
1      \     / 1010
  \      101
    11(X)    \ 1011(X)
```
只有当尾数是`0`的下一轮能增加2个，尾数是`1`的下一轮只能增加1个，这是一个斐波那契数列，`f(k)=f(k-1)+f(k+1)`

当参数为`2^k`时，结果就是`f[k]+1`
 
当斐波那契数列(f)求出后，假设给定的参数`num`的而二进制为`10010110101`
 
当`k`为10，`1<<k`为 `10000000000`
两者按位且不为0，因此需要 `+f[10]`
 
> 这里`+f[k]`可以看成将`k`位的1变为0，在后`k-1`位中存在的非连续1的数量，
> 例如`f[10]`，可以看成9位的非连续1的数量

接着，要处理 `10110101`这一段,继续遍历k

当k为7，`1<<k`为  `10000000`，两者按位且不为0， `+f[7]`

接着处理`110101`

当k为5，`1<<k`为 `100000`，两者按位且不为0，`+f[5]`

但注意，继续遍历当k为4时，按位且同样不为0，说明存在2个1连续，

例如，`110101`，但出现2个1连续，则后面的不需要继续计算了，因为存在11开头，后面一定都不合法。

-----
代码：
```js
var findIntegers = function(num) {
  let f=[];
  f[0] = 1;
  f[1] = 2;
  for (let i = 2; i < 32; ++i)
    f[i] = f[i-1]+f[i-2];
  let ans = 0, k = 30, pre_bit = 0;
  while (k >= 0) {
    if (num&(1<<k)) {
      ans += f[k];
      if (pre_bit) return ans;
      pre_bit = 1;
    }
    else
      pre_bit = 0;
    --k;
  }
  return ans+1;
};
```
 

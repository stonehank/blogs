给定一个数组`A`和一个`K`，算出和至少为`K`的子数组。

刚开始处理这个问题，我使用的是处理和为`K`的子数组的方法，再通过一个`window slide`不断处理内部的值，当其大于等于`K`的时候，
记录一下`slide`的长度。

但这个方法的问题就是一旦需要的子数组在`slide`中间，则无法获取

例如：
```
A=[-34,37,51,3,-12,-50,51,100,-47,99,34]
K=151
```

用上面的办法结果是`4`，会卡在`[51,100,-47,99]`这样的子数组中，接着是`[100,-47,99]`，无法算出`51,100`这个子数组。

正确应该是`2`。

正确思路：
1. 第一步相同，需要算出当前数与之前的和的数组。
2. 定义一个数组`d`，存放可以作为子数组开始的点。
3. `d`中的值遇到以下2种情况，可以删除。
    1. 遇到某个点`i`与`d[0]`之间的和已经`>=K`了，说明`d[0]`这个点是有效的，需要记录长度，并且删除(尝试右移)。
    2. 遇到某个点`i`加上它后，当前和比`d[d.length-1]`这个点的和更小或者相等，说明这个`i`是负值或者0，
    说明这个`d[d.length-1]`点是无效的，是不能做为子数组开始的点，需要删除。
    
代码：
```js
var shortestSubarray = function(A, K) {
  let N = A.length
  let sum = Array(N+1).fill(0)
  // 算和
  for(let i=0;i<N;i++){
    sum[i+1]=sum[i]+A[i]
  }
  // d存放从哪个点开始计算和
  let d=[]
  let res=N+1
  for(let i=0;i<N+1;i++){
    // 如果当前点(i)的和 >= d的第一个点的和
    // 说明在d[0]和i之间这一段数字的和 >= K
    // 需要算出这一段距离，并且可以删除d的第一个点
    // 循环检查
    while(d.length>0 && sum[i]-sum[d[0]]>=K){
      res=Math.min(res,i-d.shift())
    }
    // 如果当前点(i) <= d的最后一个点(有可能是上一个点)
    // 那么说明，当前点是一个0或者负值，是绝对不能做为开始点去算和的
    // 因此当前点需要pop掉
    // 循环检查
    while(d.length>0 && sum[i]<=sum[d[d.length-1]]){
      d.pop()
    }
    // 每一个点都先放入d，后续会检查这些点是否能作为计算和的开始点
    d.push(i)
  }
  return res<=N ? res : -1
};
```
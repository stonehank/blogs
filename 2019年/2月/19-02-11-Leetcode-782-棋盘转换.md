题目给出一个`N*N`矩阵，要求计算出转换为棋盘的最小步数，每次转换只能交换两行或者两列，不能转换则输出`-1`

棋盘格式：
```
1 0 1 0 1
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0
1 0 1 0 1
```

思路：

1. 能转换为棋盘的矩阵符合2个特征：
    1. 抽取某一行(列)，其他行(列)一定与这一行相同或者相反。
    
        例如某一行为`11001`，那么其他行只可能是`11001`或者`00110`。
    
    2. 每一行中`1`和`0`的数量必须不小于`Math.floor(N/2)`。

    例如这行`100010`，是不符合规则的直接返回`-1`。

2. 当判断完有效棋盘后，需要计算转换步数，由于奇数棋盘只存在唯一的解，而偶数存在两个解(取最小)。

    1. 这里使用一个假设结果，`0101010...`，也就是说，当检测到`row[0]`为`0`时，`rowMove++`，`row[1]`为`1`时，`rowMove++`...
    
    2. 当行列都检测完毕，如果`N`是偶数，我们取最小值`Math.min(rowMove,N-rowMove)`，如果`N`是奇数，`rowMove`必须为偶数
    (`rowMove`为奇数是不可能排列成的)，因此`rowMove`为奇数时，使用`N-rowMove`。
    
    由于上面的`rowMove`是整行检查，而一行中每次交换是交换2列，因此最终结果`/2`。
    
代码：
```js
var movesToChessboard = function(board) {
  let N = board.length, colToMove = 0, rowToMove = 0, rowOneCnt = 0, colOneCnt = 0;
// 一种更有效的检查每一行为相同或相反的方式
//   for (let i = 0; i < N; i++) {
//     for (let j = 0; j < N; j++) {
//       if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {
//         return -1;
//       }
//     }
//   }

  let firstRow=board[0], firstReversRow=[]
  for(let i=0;i<firstRow.length;i++){
    if(firstRow[i]===0)firstReversRow[i]=1
    else firstReversRow[i]=0
  }
  function checkValid(row){
    let v1=true,v2=true
    for(let i=0;i<board[row].length;i++){
      if(firstRow[i]!==board[row][i]){
        if(!v2 || firstReversRow[i]!==board[row][i])return false
        v1=false
      }
      if(firstReversRow[i]!==board[row][i]){
        if(!v1 || firstRow[i]!==board[row][i])return false
        v2=false
      }
    }
    return true
  }
  for(let i=0;i<N;i++){
    if(!checkValid(i))return -1
  }

  for (let i = 0; i < N; i++) {
    rowOneCnt += board[0][i];
    colOneCnt += board[i][0];
    if (board[i][0] === i % 2) rowToMove++;
    if (board[0][i] === i % 2) colToMove++;
  }
  let halfLimit=Math.floor( N / 2)
  if (rowOneCnt<halfLimit || (N-rowOneCnt)<halfLimit ||
    colOneCnt<halfLimit || (N-colOneCnt)<halfLimit) {
    return -1;
  }
// 当为奇数时，只有一种情况（move为偶数的情况）
  if (N % 2 === 1) {
    if (colToMove % 2 === 1) colToMove = N - colToMove;
    if (rowToMove % 2 === 1) rowToMove = N - rowToMove;
  } else {
    colToMove = Math.min(colToMove, N - colToMove);
    rowToMove = Math.min(rowToMove, N - rowToMove);
  }
  return (colToMove + rowToMove) / 2;
};
```
给定一个排序好的数组，两个整数`k` 和`x`，从数组中找到最靠近`x`（两数之差最小）的 `k `个数。返回的结果必须要是按升序排好的。
如果有两个数与 `x` 的差值一样，优先选择数值较小的那个数。

```
示例 1:
输入: [1,2,3,4,5], k=4, x=3
输出: [1,2,3,4]
```

```
示例 2:
输入: [1,2,3,4,5], k=4, x=-1
输出: [1,2,3,4]
```
 
这道题有多种解法，比较好想的是`O(lgN+k)`

思路：
先二分法找出`x`或者最接近`x`的位置`idx`，然后双指针分别处理`idx-1`和`idx+1`，最后将结果排序返回。

代码：
```py
class Solution(object):
    def findClosestElements(self, arr, k, x):
        """
        :type arr: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """
        N=len(arr)
        
        # 求出最接近x的位置lo
        lo,hi=0,N-1
        while lo<hi:
          mid=(lo+hi)//2
          if arr[mid]<x:lo=mid+1
          else:hi=mid
          
        # 双指针处理left和right
        ans=[]
        left,right=lo-1,lo
        while (left>=0 or right<N) and k>0:
          k-=1
          if left<0:
            ans.append(arr[right])
            right+=1
          elif right>=N:
            ans.append(arr[left])
            left-=1
          else:
            l=x-arr[left]
            r=arr[right]-x
            if l<=r:
              ans.append(arr[left])
              left-=1
            elif l>r :
              ans.append(arr[right])
              right+=1
        ans.sort()
        return ans
```

另外还有一种`O(lg(N-K))`的解法，用的是滑动窗口的道理。

思路：
1. 因为接近`x`的`k`个数一定是连续的，因此我们只需要确定这个连续数组的起始点，就可以返回结果。
2. 起点的索引一定处于`[0,N-k]`的范围内，因此我们使用二分法，只要判断出起点与`x`的差不大于终点(起点+`k`)与`x`的差即可。

代码：
```py
class Solution(object):
    def findClosestElements(self, arr, k, x):
        """
        :type arr: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """
        N=len(arr)
        lo,hi=0,N-k
        while lo<hi:
          mid=(lo+hi)//2
          if x-arr[mid]>arr[mid+k]-x:
            lo=mid+1
          else:
            hi=mid
        return arr[lo:lo+k]
```

